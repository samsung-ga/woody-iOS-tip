### Today I Learned

----

2022.10.02 (일)

<br />

<br />

개발하면서 프로퍼티와 메소드의 네이밍을 고민하는 시간이 개발 시간의 거의 절반 이상을 차지합니다. 그럼에도 불구하구 최악의 네이밍이 탄생하게 되네요.

```swift

extension UIButton {
    func setBasicProfileImageWhenNilAndEmpty(with urlString: String?) {
        if let urlString = urlString, urlString.isEmpty == false {
            self.imageView?.kf.indicatorType = .activity
            let url = URL(string: urlString)
            self.kf.setImage(with: url, for: .normal,
                             options: [.forceTransition])
        } else {
          // ...
        }
    }
}

```

버튼의 이미지를 설정하는 Extension 코드인데 setBasicProfileImageWhenNilAndEmpty ...? <br />제가 만든 메소드이긴 하지만 너무 길고.. 다른 개발자들이 잘 이해할 수 있을 지..!? 😭 
그 기준을 . 

----

[Swift Documentation API Design Guidelines](https://www.swift.org/documentation/api-design-guidelines/#naming) 를 보고 작성한 내용입니다. 

### 사용 시점의 명확성이 가장 중요하다.

프로퍼티와 메소드들은 한 번만 선언되지만 반복적으로 사용되므로 API를 설계할 때는 그것이 명확하고 정확해야 합니다. 사실 이 말은 그렇게 와닿지 않네요. 명확한 예시가 없어서.. 

### 간결함보다 명료함이 더 중요하다. 

문자는 가장 적게 사용하여 코드에 대한 이해를 하는 것이 중요합니다. 스위프트의 메소드를 만들 때 아래와 같이 파라미터를 이용해서 더 명료하게 네이밍을 할 수 있습니다. 

```swift
func insert(at element: Int) { }
func removeAll() {}
```

하지만 간결하게 작성하기 위해서 명료함을 버리면 안돼요! 무조건 명료함이 우선입니다.

### 주석을 달아라 

모든 코드에 대해 주석을 작성합니다. 문서(주석)를 작성함으로써 얻은 통찰력은 API 설계에도 엄청난 영향을 미칠 수 있으니 미루지 않기! <br />근데 주석은 최대한 작성하지 않고 메소드명과 프로퍼티명만으로 메소드의 동작을 이해하게 만드는 것이 가장 좋다라고 <클린 코드>책에 쓰여져있는데.. 그럼 뭐가 맞는걸까!? 🤔 

애플 문서를 따르는 게 좋겠어요. 

1. 주석을 작성함으로써 얻은 통찰력을 통해 API 설계를 더 명료하게 할 수 있다!
   - 만일 주석을 달기 어려운 API가 있다면, 잘못된 API를 짠 것임
2. 나중에 합류한 개발자들이 코드에 대한 이해를 더 빠르게 할 수 있다!
3. 애플이 작성한 프로퍼티와 메소드들도 대부분 주석이 달려 있다! (이것도 중요하져.. best practice를 찾아가기 위해서는 애플 코드에서 영감을 받아야 해요) 

```swift
@frozen public struct String {

    /// Creates an empty string.
    ///
    /// Using this initializer is equivalent to initializing a string with an
    /// empty string literal.
    ///
    ///     let empty = ""
    ///     let alsoEmpty = String()
    @inlinable public init()
```

그럼 주석은 어떤 식으로 작성해야할까? 

1. 주석 시작은 summary로!

**summary 규칙들** 

- .으로 끝내구 완벽한 문장을 만들지 말기
- 메소드가 무슨 기능을 하는지 설명하고 리턴값을 명시하기

```swift
/// Inserts `newHead` at the beginning of `self`.
mutating func prepend(_ newHead: Int)

/// Returns a `List` containing `head` followed by the elements
/// of `self`.
func prepending(_ head: Element) -> List

/// Removes and returns the first element of `self` if non-empty;
/// returns `nil` otherwise.
mutating func popFirst() -> Element?
```

- subscript가 접근하는 것이 무엇인지 설명하기 

```swift
/// Accesses the `index`th element.
subscript(index: Int) -> Element { get set }
```

- initializer가 생성하는 것이 무엇인지 설명하기

```swift
/// Creates an instance containing `n` repetitions of `x`.
init(count n: Int, repeatedElement x: Element)
```

- 선언된 엔티티가 무엇을 하는지 설명하기 

```swift
/// A collection that supports equally efficient insertion/removal
/// at any position.
struct List {

  /// The element at the beginning of `self`, or `nil` if self is
  /// empty.
  var first: Element?
  ...
```

2. 추가 정보는 Blank line으로 구분하기 

```swift
/// Writes the textual representation of each    ← Summary
/// element of `items` to the standard output.
///                                              ← Blank line
/// The textual representation for each item `x` ← Additional discussion
/// is generated by the expression `String(x)`.
///
/// - Parameter separator: text to be printed    ⎫
///   between items.                             ⎟
/// - Parameter terminator: text to be printed   ⎬ Parameters section
///   at the end.                                ⎟
///                                              ⎭
/// - Note: To print without a trailing          ⎫
///   newline, pass `terminator: ""`             ⎟
///                                              ⎬ Symbol commands
/// - SeeAlso: `CustomDebugStringConvertible`,   ⎟
///   `CustomStringConvertible`, `debugPrint`.   ⎭
public func print(
  _ items: Any..., separator: String = " ", terminator: String = "\n")
```

