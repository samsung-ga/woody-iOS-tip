### Today I Learned

- [Fundamental](#fundamental)
  - [사용 시점의 명확성이 가장 중요하다.](#사용-시점의-명확성이-가장-중요하다)
  - [간결함보다 명료함이 더 중요하다.](#간결함보다-명료함이-더-중요하다)
  - [주석 달기](#주석을-달아라)
- [Naming](#naming)
  - [코드를 읽는 사람이 모호하다고 느끼지 않도록 필요한 단어를 모두 포함시키기](#코드를-읽는-사람이-모호하다고-느끼지-않도록-필요한-단어를-모두-포함시키기)
  - [불필요한 말은 생략하기](#불필요한-말은-생략하기)
  - [변수, 매개변수, 관련 타입의 네이밍은 그들의 타입보다는 역할과 관련되기](#변수-매개변수-관련-타입의-네이밍은-그들의-타입보다는-역할과-관련되기)
  - [매개 변수의 역할을 명확히 하기 위해 약한 유형 정보를 보정합니다](#매개-변수의-역할을-명확히-하기-위해-약한-유형-정보를-보정합니다)
- [Strive for Fluent Usage](#strive-for-fluent-usage)
  - [문법적인 영어 구문을 선호하기](#문법적인-영어-구문을-선호하기)
  - [Factory 메소드는 "make"로 시작하기](#factory-메소드는-make로-시작하기)
  - [initializer, factory 메소드의 매개변수는 구문을 만들지 말기](#initializer-factory-메소드의-매개변수는-구문을-만들지-말기)
  - [사이드 이펙트에 따른 메소드명 짓기](#사이드-이펙트에-따른-메소드명-짓기)
  - [Boolean 메소드와 프로퍼티는 값에 변화가 일어나지 않는다면, 문장으로 읽혀야합니다.](#boolean-메소드와-프로퍼티는-값에-변화가-일어나지-않는다면-문장으로-읽혀야합니다)
  - [무엇인가를 기술하는 Protocol은 명사로 읽혀야 합니다.](#무엇인가를-기술하는-protocol은-명사로-읽혀야-합니다)
  - [기능을 설명하는 Protocol은 "able", "ible", 또는 "ing" 접미사를 이용해서 네이밍 짓기](#기능을-설명하는-protocol은-able-ible-또는-ing-접미사를-이용해서-네이밍-짓기)
  - [이외의 다른 프로퍼티, 변수, 상수의 이름은 명사로 읽혀야한다.](#이외의-다른-프로퍼티-변수-상수의-이름은-명사로-읽혀야한다)
- [Conventions](#conventions)
  - [Free Function보다는 메소드와 프로퍼티를 선호하기](#free-function보다는-메소드와-프로퍼티를-선호하기)
  - [대소문자 표기법 따르기](#대소문자-표기법-따르기)
  - [메소드들의 기능들이 같다면 기본 이름 공유하기](#메소드들의-기능들이-같다면-기본-이름-공유하기)
  - [Parmeter(매개 변수)과 Argument (인수)](#parmeter매개-변수과-argument-인수)


----

2022.10.02 (일)

<br />

개발하면서 프로퍼티와 메소드의 네이밍을 고민하는 시간이 개발 시간의 거의 절반 이상을 차지합니다. 그럼에도 불구하구 최악의 네이밍이 탄생하게 되네요.

```swift

extension UIButton {
    func setBasicProfileImageWhenNilAndEmpty(with urlString: String?) {
        if let urlString = urlString, urlString.isEmpty == false {
            self.imageView?.kf.indicatorType = .activity
            let url = URL(string: urlString)
            self.kf.setImage(with: url, for: .normal,
                             options: [.forceTransition])
        } else {
          // ...
        }
    }
}

```

버튼의 이미지를 설정하는 Extension 코드인데 setBasicProfileImageWhenNilAndEmpty ...? <br />제가 만든 메소드이긴 하지만 너무 길고.. 다른 개발자들이 잘 이해할 수 있을 지..!? 😭 
그 기준을 [Swift Documentation API Design Guidelines](https://www.swift.org/documentation/api-design-guidelines/#naming) 문서를 읽으면서 찾아봐요. 

----

## Fundamental

### 사용 시점의 명확성이 가장 중요하다.

프로퍼티와 메소드들은 한 번만 선언되지만 반복적으로 사용되므로 API를 설계할 때는 그것이 명확하고 정확해야 한다는데, 사실 이 말은 그렇게 와닿지 않아요. 명확한 예시가 없어서.. 

### 간결함보다 명료함이 더 중요하다. 

문자는 가장 적게 사용하여 코드에 대한 이해를 하는 것이 중요합니다. 스위프트의 메소드를 만들 때 아래와 같이 파라미터를 이용해서 더 명료하게 네이밍을 할 수 있습니다. 

```swift
func insert(at element: Int) { }
func removeAll() {}
```

하지만 간결하게 작성하기 위해서 명료함을 버리면 안돼요! 무조건 명료함이 우선입니다.

### 주석을 달아라 

모든 코드에 대해 주석을 작성합니다. 문서(주석)를 작성함으로써 얻은 통찰력은 API 설계에도 엄청난 영향을 미칠 수 있으니 미루지 않기! <br />근데 주석은 최대한 작성하지 않고 메소드명과 프로퍼티명만으로 메소드의 동작을 이해하게 만드는 것이 가장 좋다라고 <클린 코드>책에 쓰여져있는데.. 그럼 뭐가 맞는걸까!? 🤔 

애플 문서를 따르는 게 좋겠어요. 

1. 주석을 작성함으로써 얻은 통찰력을 통해 API 설계를 더 명료하게 할 수 있다!
   - 만일 주석을 달기 어려운 API가 있다면, 잘못된 API를 짠 것임
2. 나중에 합류한 개발자들이 코드에 대한 이해를 더 빠르게 할 수 있다!
3. 애플이 작성한 프로퍼티와 메소드들도 대부분 주석이 달려 있다! (이것도 중요하져.. best practice를 찾아가기 위해서는 애플 코드에서 영감을 받아야 해요) 

```swift
@frozen public struct String {

    /// Creates an empty string.
    ///
    /// Using this initializer is equivalent to initializing a string with an
    /// empty string literal.
    ///
    ///     let empty = ""
    ///     let alsoEmpty = String()
    @inlinable public init()
```

그럼 주석은 어떤 식으로 작성해야할까? 

1. 주석 시작은 summary로!

- .으로 끝내구 완벽한 문장을 만들지 말기
- 메소드가 무슨 기능을 하는지 설명하고 리턴값을 명시하기

```swift
/// Inserts `newHead` at the beginning of `self`.
mutating func prepend(_ newHead: Int)

/// Returns a `List` containing `head` followed by the elements
/// of `self`.
func prepending(_ head: Element) -> List

/// Removes and returns the first element of `self` if non-empty;
/// returns `nil` otherwise.
mutating func popFirst() -> Element?
```

- subscript가 접근하는 것이 무엇인지 설명하기 

```swift
/// Accesses the `index`th element.
subscript(index: Int) -> Element { get set }
```

- initializer가 생성하는 것이 무엇인지 설명하기

```swift
/// Creates an instance containing `n` repetitions of `x`.
init(count n: Int, repeatedElement x: Element)
```

- 선언된 엔티티가 무엇을 하는지 설명하기 

```swift
/// A collection that supports equally efficient insertion/removal
/// at any position.
struct List {

  /// The element at the beginning of `self`, or `nil` if self is
  /// empty.
  var first: Element?
  ...
```

2. 추가 정보는 Blank line으로 구분하기 

```swift
/// Writes the textual representation of each    ← Summary
/// element of `items` to the standard output.
///                                              ← Blank line
/// The textual representation for each item `x` ← Additional discussion
/// is generated by the expression `String(x)`.
///
/// - Parameter separator: text to be printed    ⎫
///   between items.                             ⎟
/// - Parameter terminator: text to be printed   ⎬ Parameters section
///   at the end.                                ⎟
///                                              ⎭
/// - Note: To print without a trailing          ⎫
///   newline, pass `terminator: ""`             ⎟
///                                              ⎬ Symbol commands
/// - SeeAlso: `CustomDebugStringConvertible`,   ⎟
///   `CustomStringConvertible`, `debugPrint`.   ⎭
public func print(
  _ items: Any..., separator: String = " ", terminator: String = "\n")
```



----

2022.10.02 (일)

<br />

## Naming

### 코드를 읽는 사람이 모호하다고 느끼지 않도록 필요한 단어를 모두 포함시키기

at 파라미터를 통해 x를 제거하는 것이 아니라 제거할 요소의 위치를 작성해야한다는 사실을 암시할 수 있습니다. 

```swift
extension List {   
  public mutating func remove(at position: Index) -> Element
} 

employees.remove(at: x) // ✅ 
employees.remove(x) // ☠️ unclear: are we removing x?
```

### 불필요한 말은 생략하기

더 명확하게 하기 위한 의도는 좋지만, 중복된 정보를 주는 단어들은 생략해야 합니다. 애매함을 피하기 위해 정보를 반복해야 하는 경우도 있지만 일반적으론 매개변수를 통해 역할을 설명하는 단어를 사용하는 것이 더 좋다구 하네용 <br />아래 예시에선 Element가 특별한 내용을 전달하지 않고 cancelButton과 중복되기 때문에 생략해주어야 해요.

```swift
public mutating func remove(_ member: Element) -> Element?
allViews.remove(cancelButton) // ✅

public mutating func removeElement(_ member: Element) -> Element?
allViews.removeElement(cancelButton) // ☠️ 
```

### 변수, 매개변수, 관련 타입의 네이밍은 그들의 타입보다는 역할과 관련되기

```swift
var string = "Hello" // ☠️ 
protocol ViewController {
  associatedtype ViewType : View // ☠️ 
}
class ProductionLine {
  func restock(from widgetFactory: WidgetFactory) // ☠️ 
}

var greeting = "Hello" // ✅
protocol ViewController {
  associatedtype ContentView : View // ✅
}
class ProductionLine {
  func restock(from supplier: WidgetFactory) // ✅
}
```

만일, 역할과 타입과 일치해서 네이밍을 하게 된다면 뒤에 더 추가 설명을 붙여주라고 합니다.<br /> 아래 예시에서는 Protocol을 붙여주었네요. 

```swift
protocol Sequence {
  associatedtype Iterator : IteratorProtocol
}
protocol IteratorProtocol { ... }

```

### 매개 변수의 역할을 명확히 하기 위해 약한 유형 정보를 보정합니다

위에서 불필요한 말은 생략하라고 했는데 여기선, 약간의 보정이 필요하다고 하네요. 매개변수만으로는 설명이 모호해지는 경우엔 역할을 설명하는 명사를 붙입니다. 

```swift
func add(_ observer: NSObject, for keyPath: String)
grid.add(self, for: graphics) // ☠️

func addObserver(_ observer: NSObject, forKeyPath path: String)
grid.addObserver(self, forKeyPath: graphics) // ✅
```

## Strive for Fluent Usage 

### 문법적인 영어 구문을 선호하기

```swift
x.insert(y, at: z) // x insert y at z
x.subViews(havingColor: y) // x's subviews having color y

x.insert(y, position: z) // ☠️
x.subViews(color: y) // ☠️
```

1,2번째 매개변수 이후엔 fluent하지 않아도 된다고 합니당 의미에 영향을 미치지 않는다면은! 

```swift
AudioUnit.instantiate(
  with: description, 
  options: [.inProcess], completionHandler: stopProgressBar)
```

### Factory 메소드는 "make"로 시작하기

라는데 완전 처음 알았네요. 보통 "create", "init"을 많이 썼는데 새롭군요

### initializer, factory 메소드의 매개변수는 구문을 만들지 말기

문장을 만들지 말고, 무엇이 필요한 지 적어야 합니다. <br />

Color는 red, green, blue가 필요하고, widget은 gears, spindles가 필요하고, Link는 target이 필요합니다. 만일 구문을 만들어버린다면 오히려 혼란을 야기할 수 있어요.

```swift
// ✅ 좋은 케이스
let foreground = Color(red: 32, green: 64, blue: 128)
let newPart = factory.makeWidget(gears: 42, spindles: 14)
let ref = Link(target: destination)

// ☠️ 안좋은 케이스 
let foreground = Color(havingRGBValuesRed: 32, green: 64, andBlue: 128)
let newPart = factory.makeWidget(havingGearCount: 42, andSpindleCount: 14)
let ref = Link(to: destination)

```

### 사이드 이펙트에 따른 메소드명 짓기

사이드 이펙트가 무엇일까요? 사이드 이펙트는 해당 프로퍼티를 이용해 일어난 어떤 일을 의미합니다. 프로퍼티 x를 변화시키는 메소드를 수행한다면 이것은 사이드 이펙트가 있는 메소드입니다. 프로퍼티 x를 출력하는 것 또한 사이드 이펙트가 있는 메소드 입니다. 사이드 이펙트가 없는 메소드의 네이밍은 명사구로 읽히면 좋습니다. 
- 사이드 이펙트 있는 메소드 ex) print(x), x.sort(), x.append(y)
- 사이드 이펙트 없는 메소드 ex) x.distance(to: y), i.successor() 

값에 변화가 일어나는 메소드는 동사, 일어나지 않는다면 "ed"나 "ing"를 붙여 차이점을 보여줍니다. "ed"를 선호하되, 문법적으로 말이 안된다면 "ing"를 붙이라고 하네요.
- 값에변화가 일어나는 메소드 ex) x.sort(), x.append(y)
- 값에 변화가 일어나지 않는 메소드 ex) z = x.sorted(), z = x.appending(y) 

### Boolean 메소드와 프로퍼티는 값에 변화가 일어나지 않는다면, 문장으로 읽혀야합니다.

ex) x.isEmpty(), line1.intersects(line2)

### 무엇인가를 기술하는 Protocol은 명사로 읽혀야 합니다.

ex) Collection

### 기능을 설명하는 Protocol은 "able", "ible", 또는 "ing" 접미사를 이용해서 네이밍 짓기

ex) Equatable, ProgressReporting

### 이외의 다른 프로퍼티, 변수, 상수의 이름은 명사로 읽혀야한다.

## Conventions

### Free Function보다는 메소드와 프로퍼티를 선호하기

아래와 같은 특별한 케이스 말고는 메소드와 프로퍼티를 선호하라고 하는데 Free Function이 무엇일까? 멤버가 없는 함수를 말합니다. 아래 함수들은 어디에도 속하지 않는 함수들이에요. 그렇기에 어디서든 사용할 수 있습니다.

```swift
min(x, y, z)
print(x)
sin(x)
```

### 대소문자 표기법 따르기

타입과 프로토콜 빼고는 모두 lowerCamelCase!! <br />그치만 예외도 있는듯.. utf8나 id 같이 미국 영어에서 일반적으로 대문자로 표시되는 것들이 예외입니다

```swift
var utf8Bytes: [UTF8.CodeUnit]
var isRepresentableAsASCII = true
var userSMTPServer: SecureSMTPServer
```

### 메소드들의 기능들이 같다면 기본 이름 공유하기

```swift
// ✅ 좋은 케이스
extension Shape {
  func contains(_ other: Point) -> Bool { ... }
  func contains(_ other: Shape) -> Bool { ... }
  func contains(_ other: LineSegment) -> Bool { ... }
}
```

아래와 같이 Generic 타입으로 선언해도 좋아요.

```swift
// ✅ 좋은 케이스
extension Collection where Element : Equatable {
  func contains(_ sought: Element) -> Bool { ... }
}
```

완전 다른 기능을 할 때에는 같으면 안돼요.

```swift
// ☠️ 안 좋은 케이스
extension Database {
  /// Rebuilds the database's search index
  func index() { ... }

  /// Returns the `n`th row in the given table.
  func index(_ n: Int, inTable: TableID) -> TableRow { ... }
}
```

리턴 타입을 오버로드하는 행위는 피해야 해요!

```swift
// ☠️ 안 좋은 케이스
extension Box {
  func value() -> Int? { ... }
  func value() -> String? { ... }
}
```

### Parmeter(매개 변수)과 Argument (인수)

default가 없는 매개 변수를 앞으로 배치시켜 메소드가 호출되는 것이 안정적이 되도록 하라구 해요. <br />인수를 제대로 구분하지 못할 경우엔 인수 생략!.<br/>타입 변환하는 메소드의 첫번째 인수는 생략!<br/>첫 번째 인수는 상황에 따라 전치사로 하거나 생략하기!

```swift
a.moveTo(x: b, y: c)
a.fadeFrom(red: b, green: c, blue: d)

x.addSubview(y) // 문법적 구문

view.dismiss(animated: false) // 문법적 구문이 아닐경우엔 label을 붙여야 함
```

<br/>


<br/>

<br/>

- https://www.swift.org/documentation/api-design-guidelines/#namin 

파파고 최고!

  func contains(_ other: Point) -> Bool { ... }ㅏ파
